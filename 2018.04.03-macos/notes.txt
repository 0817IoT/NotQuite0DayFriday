Heap overflow in necp_client_action syscall

Overview:
The following is a write-up of a heap overflow bug found while fuzzing the macOS
necp_client_action syscall.  The necp_client_action syscall is part of the
Network Extension Control Policy kernel subsystem.

Affected Versions:
XNU kernel versions 4570.1.46 and later until 4570.51.1

Discovery Environment:
macOS High Sierra inside VMware Fusion

Exercising:
$ clang poc.c -o poc
$ ./poc
$ clang leak.c -o leak
$ ./leak

Triage:
While investigating the NECP subsystem during the implementation of a syscall
fuzzer for the necp_client_action syscall, we traced one code path that lead to
a memcpy with an unchecked user-provided length.

Looking through the necp_client_action function in bsd/net/necp_client.c, we can
see that it is merely a wrapper for several different actions.
The vulnerable case occurs when the action parameter to necp_client_action is
set to NECP_CLIENT_UPDATE_CACHE.  necp_client_action then calls the function
necp_client_update_cache.

The necp_client_update_cache function is meant to manage TCP related statistics
information for a connection.  Thus, this function will error out if not called
with a NECP client UUID that has a valid connection assigned to it. After
checking the UUID, this copies in a user provided necp_cache_buffer structure.
This structure, looks as follows:

	typedef struct necp_cache_buffer {
		u_int8_t                necp_cache_buf_type;    //  NECP_CLIENT_CACHE_TYPE_*
		u_int8_t                necp_cache_buf_ver;     //  NECP_CLIENT_CACHE_TYPE_*_VER
		u_int32_t               necp_cache_buf_size;
		mach_vm_address_t       necp_cache_buf_addr;
	} necp_cache_buffer;

If the buf_type and buf_ver are NECP_CLIENT_CACHE_TYPE_TFO and
NECP_CLIENT_CACHE_TYPE_TFO_VER_1 respectively, necp_client_update_cache will
attempt to read in a necp_tcp_tfo_cache structure and call
tcp_heuristics_tfo_update with it.  This structure, shown below, is notable as
it includes a user controlled buffer of up to 0x10 characters and a length for
that buffer.

	typedef struct necp_tcp_tfo_cache {
		u_int8_t                necp_tcp_tfo_cookie[NECP_TFO_COOKIE_LEN_MAX];
		u_int8_t                necp_tcp_tfo_cookie_len;
		u_int8_t                necp_tcp_tfo_heuristics_success:1; // TFO succeeded with data in the SYN
		u_int8_t                necp_tcp_tfo_heuristics_loss:1; // TFO SYN-loss with data
		u_int8_t                necp_tcp_tfo_heuristics_middlebox:1; // TFO middlebox detected
		u_int8_t                necp_tcp_tfo_heuristics_success_req:1; // TFO succeeded with the TFO-option in the SYN
		u_int8_t                necp_tcp_tfo_heuristics_loss_req:1; // TFO SYN-loss with the TFO-option
		u_int8_t                necp_tcp_tfo_heuristics_rst_data:1; // Recevied RST upon SYN with data in the SYN
		u_int8_t                necp_tcp_tfo_heuristics_rst_req:1; // Received RST upon SYN with the TFO-option
	} necp_tcp_tfo_cache;

The tcp_heuristics_tfo_update (in bsd/netinet/tcp_cache.c) processes the
necp_tcp_tfo_cache structure, ultimately running into this code:

	if (necp_buffer->necp_tcp_tfo_cookie_len != 0) {
		tcp_cache_set_cookie_common(&tcks,
			necp_buffer->necp_tcp_tfo_cookie, necp_buffer->necp_tcp_tfo_cookie_len);
	}

If the cookie length is not zero, it will call tcp_cache_set_cookie_common,
shown below. This function looks up tcp_cache structure associated with the
current connection and copies the cookie to that structure.

	static void tcp_cache_set_cookie_common(struct tcp_cache_key_src *tcks, u_char *cookie, u_int8_t len)
	{
		struct tcp_cache_head *head;
		struct tcp_cache *tpcache;

		/* Call lookup/create function */
		tpcache = tcp_getcache_with_lock(tcks, 1, &head);
		if (tpcache == NULL)
			return;

		tpcache->tc_tfo_cookie_len = len;
		memcpy(tpcache->tc_tfo_cookie, cookie, len);

		tcp_cache_unlock(head);
	}

However, the tc_tfo_cookie is at most 0x10 bytes long.  Thus, if an attacker
specified a parameter larger than 0x10 bytes, the memcpy would overflow the
tpcache structure on the heap and write data past it.  As the source cookie is
located on the stack, the heap will be overflown with the stack contents.
Immediately after the cookie on the stack is the rest of the necp_tcp_tfo_cache
structure.  However, the remaining fields in the structure only account for a
few bytes.  After the end of the necp_tcp_tfo_cache structure, the user is not
able to control any other bytes that will be used in the overflow.

The tcp_getcache_with_lock function will attempt to find an existing tcp_cache
structure for the local and remote hosts.  If one is not found, a new one will
be created.  However, there is a limit on the number of tcp_cache structures
that will be created.

Bug Fix:
So how was this bug fixed?  While the source code for the XNU kernel has not
been updated to reflect the latest available XNU kernel binary, we can take a
look at the disassembly to understand the fix.  In the 4570.51.1 kernel at
address 0xFFFFFF800060DE59, the following instructions were added:

	cmp ebx, 0x10
	mov edx, 0x10
	cmovb edx, ebx
	...
	copies edx bytes from necp_tcp_tfo_cookie (rsi) to tpcache (rdi)

This assembly compares the necp_tcp_tfo_cookie_len parameter to 0x10, and only
if it is less than 0x10 does that value get used in memcpy.  Thus any attempt to
write more than 0x10 bytes results in 0x10 bytes being written.

Heap Analysis:
This bug allows for a heap overflow in the kernel heap.  More specifically, the
overflown tcp_cache structure is in the kalloc.80 zone.  As such, any
exploitation attempts will naturally look to overflow the tcp_cache structure
into another kalloc.80 zone.  As such, we began our analysis by looking for
kalloc.80 allocations.  While the number of kalloc.80 allocations was quite
limited, we were able to find three useful allocations.

The first allocation is made by the necp_set_socket_attributes function (in
bsd/net/necp_client.c).  This function allows a user to tag a socket with a
domain and account attribute. These strings are allowed to be any size and can
be created, read, and freed whenever the user wants.  These allocations are
great for reading out any leaked content.

The second allocation found was the IO vector metadata structure (struct uio,
defined in bsd/sys/uio_internal.h).  This structure is used for doing scatter
gather memory operations in the kernel.  When the uio structure is created via
uio_create (in bsd/kern/kern_subr.c), the IO vector information array is
stored immediately after the uio structure.  As such, by adjusting the number of
IO vectors stored in the uio structure, we can control size.  By creating a uio
structure with a single IO vector, the uio structure will be declared in the
kalloc.80 zone.  These structures can be declared and freed through the use of
the recvmsg_x syscall.

The third allocation is used in the POSIX shared memory subsystem (in
bsd/kern/posix_shm.c).  This subsystem allows processes to setup shared memory
regions that are mapped in both processes.  These shared memory regions are
tracked with the pshminfo structure, shown below.  This structure will be useful
during exploitation due to the usecount that is early on in the structure.

#define PSHMNAMLEN  31  /* maximum name segment length we bother with */
struct pshminfo {
	unsigned int  pshm_flags;
	unsigned int  pshm_usecount;
	off_t   pshm_length;
	mode_t    pshm_mode;
	uid_t   pshm_uid;
	gid_t   pshm_gid;
	char    pshm_name[PSHMNAMLEN + 1];  /* segment name */
	struct pshmobj *pshm_memobjects;
	struct label* pshm_label;
};

Obtaining an information Leak:

Now that we have our target allocations setup, we can begin working on the
exploit.  Our first goal will be to obtain an information leak and deduce the
kernel slide.  This is achieved by flooding the kalloc.80 zone with necp
attribute strings, freeing every other necp attribute string, and then causing
the overflow.  Once the overflow has occurred, we will read out the necp
attribute strings looking for one that has had its contents changed.  This leak
is demonstrated in the included leak.c file.

Exploit Development:



